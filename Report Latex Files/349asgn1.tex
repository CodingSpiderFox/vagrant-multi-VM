\documentclass[12pt]{extarticle}

\usepackage[utf8]{inputenc}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstset{language=bash,
  basicstyle=\ttfamily,
  showstringspaces=false,
  commentstyle=\color{red},
  keywordstyle=\color{blue}
}

\setlength{\parskip}{12pt}

\title{COSC349 Assignment 1}
\author{Bradley Windybank - 4353100}
\date{August 2019}

\begin{document}


\maketitle

\section{About}
\subsection{Application Explanation}
This application is a collaborative task list application. It uses three virtual machines that communicate with each other over a local network to make everything work. One VM hosts a web app that the user can interact with to view, save, and delete tasks. Another VM takes requests from the other two VMs and retrieves, deletes or saves tasks depending on the contents of the request. The third VM is a Node.js JavaScript application that prints the tasks to a PDF. This VM can be interacted with through the use of a bash script.

\subsection{VM interaction}
The three VMs interact over a private network. Each machine has its own static IP address. The React web app and PDF program communicate to the Express server through RESTful API requests. They recieve information back in JSON format. The reason for seperating each of my services into seperate VMs allows for several advantages over hosting them all on one VM. One benefit is that each VM can be restarted independently rather than having to restart one VM. This improves reload times when a service needs to be reloaded in a case of error or code modification or the like. VM separation also allows for better separation of the commands that provision the virtual machines. This means that each set up process does not interfere with that of the others and it is also easier to make changes to each provisioning script without worrying about affecting the other services. VM separation also allows for easy expansion of services accessing the server. This means another VM could be easily created to host a desktop GUI program that could be used to bulk edit tasks, and a mobile app for task management could communicate over the network to talk with the server with ease. With seperating each service onto a seperate VM, resources such as memory and storage space can be more specifically allocated to each service, so as to reduce unnecessary resource consumption. Though this may only be a benefit with a large scale system with more users or more complex services.

\section{VM Provisioning}
\subsection{Initial Setup}
\begin{itemize}
\item After installing prerequisites, (Vagrant, VirtualBox) open up a terminal window.
\item Change directory to the folder you want this project to be enclosed within.
\item Then clone the repository.
\item Next run  \lstinline|cd vagrant-multi-VM|
\item The project is viewable and editable from this directory.
\item The command  \lstinline|vagrant up| in terminal will run the project.
\item You can now view the web app from \url{http://localhost:3001} and can enter and delete notes.
\item More information regarding setup is available from the GitHub readme file.
\end{itemize}

\subsection{Download and Build Time}
\begin{itemize}
\item 400MB approx for downloads of packages/dependencies during provisioning.
\item 270MB approx download for box file.
\item 5MB repo clone (Zipped).
\item \lstinline|vagrant up| from scratch or \lstinline|vagrant up --provision| takes 4.5 to 5 minutes to complete (this includes downloads and provisioning). Tested on University Library WiFi (50Mbps Download Speed).
\item  \lstinline|vagrant up| any time after (without provisioning) only takes 1 minute.
\end{itemize}

\subsection{Setup Automation}
Setup automation is done using inline shell scripts within the vagrantfile. Therefore, all a user needs to do to set up the project, as shown in the steps above, is install Vagrant and Virtualbox, then run  \lstinline|vagrant up| to start the automatic provisioning. The steps taken in each provisioning script are as follows.

\subsubsection*{Server VM}
\begin{itemize}
\item The package sources are updated with new entries for node and mongodb.
\item Node and Mongo are installed.
\item The \lstinline|forever| package that keeps node scripts running permanently is installed using NPM.
\item The working directory is then changed to that of the source files for the server VM.
\item  \lstinline|npm install| is run to install needed node packages.
\item The server node script is now run using \lstinline|forever|
\end{itemize}

\subsubsection*{Web App VM}
\begin{itemize}
\item The package sources are updated with new entries for node.
\item Node is installed.
\item The working directory is then changed to that of the source files for the web app VM.
\item  \lstinline|npm install| is run to install needed node packages.
\item The web app is then run using \lstinline|nohup| which runs the script in the background. 
\end{itemize}

\subsubsection*{PDF VM}
\begin{itemize}
\item The package sources are updated with new entries for node.
\item Node is installed.
\item The working directory is then changed to that of the source files for the web app VM.
\item  \lstinline|npm install| is run to install needed node packages.
\item The PDF node script is now run.
\item The output file is then moved to the root directory.
\end{itemize}

\section{Use of the Application}
The application is primarily used through a web interface. The user can type a task into the text box, then save it using the button below the box. The user can then delete all tasks using the red button marked 'Delete All'. Or they can delete tasks one by one using the 'x' icons on the right of each task.

If the user wants to print out all tasks to a formatted PDF file, they need to open up a terminal window in the root directory of the project, and then enter  \lstinline|chmod +x task-pdf-script.sh|, then the script can be run by entering \lstinline|./task-pdf-script.sh| after which the user can then find the pdf file with the tasks listed within. This command needs to be then re-entered every time the user wants to update the file with the current contents of the list of tasks.

Below should be a link containing a recording of the mentioned interactions with the system. 

(INCLUDE RECORDING OF ALL FUNCTIONS)

\section{Further Expansion}
\subsection{Use of Git/GitHub}
The use of Git/GitHub in this project gives several advantages. One is that it allows for easy version control. The commit history can be looked back on and changes can be reverted or branched if needed. It also allows for easy modification by others and collaboration with others. Many people can work on the same repo with ease and the codebase can also be forked into new projects. 

\subsection{Setup for Devlopment and Testing}
The setup for development and testing is as follows (for macOS):
\begin{itemize}
\subsubsection*{Initial Setup}
\item Install mongoDB by following instructions here: \url{https://treehouse.github.io/installation-guides/mac/mongo-mac.html}
\item Install VSCode (or editor of choice): \url{https://code.visualstudio.com/}
\item Install Node LTS version: \url{https://nodejs.org/en/download/}
\item Open up a terminal window.
\item Change directory to the folder you want this project to be enclosed within.
\item Then clone the repository \lstinline|git clone <URL>| at: \url{https://github.com/bradwindy/vagrant-multi-VM.git}
\item This folder can now be opened in your editor of choice.

\subsubsection*{Server}
\item First the server must be run. In a terminal window at the root directory of the project, enter \lstinline|cd vm-2| which takes you to the server directory. Next enter \lstinline|npm run start| to start the server.
\item If any changes are made to the server code, you will need to stop the server process using Ctrl+C and restart it again using  \lstinline|npm run start| before any changes are visible.

\subsubsection*{Web App}
\item To run a version of the web app for development. First you must change all URLs in the code that mention the IP address and port 192.168.55.11:3000 to instead be localhost:3000
\item Then open another terminal window at the root directory of the project, enter \lstinline|cd vm-1| which takes you to the web app directory. Next enter \lstinline|npm run start| to start the web app. Press 'y' when prompted about ports.
\item The app is now viewable at: \url{http://localhost:3001} Changes made to any of the code in the web app directory will be automatically loaded on save.

\subsubsection*{PDF printing program}
\item In a terminal window at the root directory of the project, enter \lstinline|cd vm-3| which takes you to the PDF program directory. 
\item Then enter \lstinline|npm run start| to run the PDF printing program.
\item If any changes are made to the list of tasks, this program can just be run again to overwrite the PDF file.

\end{itemize}

All these instructions are also available in the README file in the repo.

\subsection{Possible Modifications}
editing tasks
\subsection{Re-Running VM's}

\section{Development Process}
\subsection{Issue Driven Development}
\subsection{Development Timeline}
(Commit History)


\end{document}